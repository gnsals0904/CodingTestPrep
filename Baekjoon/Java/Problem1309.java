package ssafy_git;

import java.util.Scanner;

/**
 * [S1] 백준 1309 동물원
 * 메모리 : 21144 KB
 * 시간 : 216 ms
 * 코드 길이 : 598 B
 * 아이디어 : DP로 문제를 풀어야하는건 알았지만 규칙을 찾기가 너무 어려웠다. 2차원 DP 배열로
 * 메모이제이션 기법을 사용하여 해결했다. 한 행에 놓을 수 있는 경우의 수를 이전 행에 놓은 경우의 수와
 * 연계하여 DP 배열에 저장하여 해결했다.
 *
 * @author 김훈민
 * @see <a href="https://www.acmicpc.net/problem/1309">
 *
 */
public class Problem1309 {
    public static void main(String[] args) {
        // 입력받기 위한 스캐너 객체 생성
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        // x = 0 은 비어있으므로 N + 1 까지 생성한다. 경우의 수가 한 행에 사자를 안넣은 경우, 왼쪽에 1마리만 넣은경우, 오른쪽에 1마리만
        // 넣은경우로 총 3가지 경우이므로 y는 3이다.
        int[][] dp = new int[N + 1][3];
        // 각 경우의 수 맨 처음은 1이다. 왜냐하면 이전 행의 영향을 받지 않기 때문이다.
        dp[1][0] = 1;
        dp[1][1] = 1;
        dp[1][2] = 1;
        // 내가 궁금한 값까지 반복하며 계산하여 2차원 DP 배열에 기록하며 진행한다.
        for(int i = 2; i < N + 1; i++){
            // y == 0 인 경우는 i번째 행에 사자를 놓지 않은 경우이다.
            // 이전 행의 결과에 관련없이 사자를 놓지 않는 경우는 모두 가능하므로 이전 행의 경우의 수를 모두 더한다
            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901;
            // y == 1 인 경우는 i번째 행에 왼쪽에 사자를 놓는 경우이다.
            // 이 경우 이전 행에 사자를 놓지 않거나 오른쪽에 놓아야만한다.
            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901;
            // y == 2 인 경우는 i번째 행에 오른쪽에 사자를 놓는 경우이다.
            // 이 경우 이전 행에 사자를 놓지 않거나 왼쪽에 놓았어야한다.
            dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901;
            // 위 경우 3개를 모두 더하며 진행한다.
        }
        // 내가 찾는 값의 모든 경우의 수를 더하여 계산하고 출력한다.
        System.out.println((dp[N][0] + dp[N][1] + dp[N][2]) % 9901);
    }
}
